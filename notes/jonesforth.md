# JonesForth Notes

- "LISP is the ultimate high-level language, ... But FORTH is in some ways the ultimate in low level programming."
- Dictionary header: link, length (5-bits)/flags (3-bits), name (padded 32-bit words), definition
- LATEST contains pointer to latest entry
- Redefinition allowed (replace, in terms of old, etc.)
- Direct threading (calls without CALL, addresses only)
- NEXT (macro) ending primitives
- EXIT ending secondaries
- Indirect threading: Codeword points to "interpreter" or directly to machine code
- DOCOL: store next word on return stack before entering
- QUIT resets internal state and starts reading and interpreting commands (e.g. "quit" from your app)
- Only /MOD is primitive (/ and MOD defined in terms)
- NEGATE is the FORTH bitwise "NOT" function
- EXIT pops return stack and does NEXT
- LIT picks up value inline, pushes to stack and skips
- Colon: Reads WORD, CREATEs header, appends DOCOL, marks HIDDEN, starts compiling [
- Semicolon: unHIDDEN, stops compiling ]
- Can HIDE SOMETHING or LATEST @ HIDDEN the latest word
- IMMEDIATE can be in the form : FOO IMMEDIATE ... ; or : FOO ... ; IMMEDIATE
- Append code word with ' FOO ,
- QUIT clear return stack, and INTERPRETs forever (doesn't EXIT)
- INTERPRET dictionary? Immediate? Number? Compiling? Error
- Doesn't implement DOES>
- Truth values are not -1
- Variables and constants are DOCOL words?
- Indirect threaded, but doesn't make use of indirection
- Initial constants: VERSION R0 (top of return stack) DOCOL (pointer to) F_IMMED F_HIDDEN F_LENMASK (flags/masks) SYS_* (Linux syscalls)
- Initial variables: STATE (compiling?) LATEST HERE S0 BASE
- Initial primitives:
  DROP SWAP DUP OVER ROT -ROT 2DROP 2DUP 2SWAP ?DUP 1+ 1- 4+ 4- + - *
  /MOD = <> < > <= >= 0= 0<> 0< 0> 0<= 0>= AND OR XOR INVERT
  EXIT ! @ +! -! C! C@ C@C! CMOVE
  >R R> RSP@ RSP! RDROP DSP@ DSP!
  KEY EMIT WORD NUMBER FIND >CFA >DFA
  CREATE , [ ] : ; IMMEDIATE HIDDEN HIDE '
  BRANCH 0BRANCH LITSTRING TELL
  QUIT INTERPRET CHAR EXECUTE SYSCALL3 SYSCALL2 SYSCALL1 SYSCALL0

: / /MOD SWAP DROP ;
: MOD /MOD DROP ;
: '\n' 10 ;
: BL 32 ; \ BL (BLank) is a standard FORTH word for space.
: CR '\n' EMIT ;
: SPACE BL EMIT ;
: NEGATE 0 SWAP - ;
: TRUE -1 ;
: FALSE 0 ;
: NOT 0= ;
: LITERAL IMMEDIATE ' LIT , , ;
: ':' [ CHAR : ] LITERAL ;
: ';' [ CHAR ; ] LITERAL ;
: '(' [ CHAR ( ] LITERAL ;
: ')' [ CHAR ) ] LITERAL ;
: '"' [ CHAR " ] LITERAL ;
: 'A' [ CHAR A ] LITERAL ;
: '0' [ CHAR 0 ] LITERAL ;
: '-' [ CHAR - ] LITERAL ;
: '.' [ CHAR . ] LITERAL ;
: [COMPILE] IMMEDIATE WORD FIND >CFA , ;
: RECURSE IMMEDIATE LATEST @ >CFA , ;
: IF IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: THEN IMMEDIATE DUP HERE @ SWAP - SWAP ! ;
: ELSE IMMEDIATE ' BRANCH , HERE @ 0 , SWAP DUP HERE @ SWAP - SWAP ! ;
: BEGIN IMMEDIATE HERE @ ;
: UNTIL IMMEDIATE ' 0BRANCH , HERE @ - , ;
: AGAIN IMMEDIATE ' BRANCH , HERE @ - , ;
: WHILE IMMEDIATE ' 0BRANCH , HERE @ 0 , ;
: REPEAT IMMEDIATE ' BRANCH , SWAP HERE @ - , DUP HERE @ SWAP - SWAP ! ;
: UNLESS IMMEDIATE ' NOT , [COMPILE] IF ;
: ( IMMEDIATE 1 BEGIN KEY DUP '(' = IF DROP 1+ ELSE ')' = IF 1- THEN THEN DUP 0= UNTIL DROP ;
: NIP SWAP DROP ;
: TUCK SWAP OVER ;
: PICK 1+ 4 * DSP@ + @ ;
: SPACES BEGIN DUP 0> WHILE SPACE 1- REPEAT DROP ;
: DECIMAL 10 BASE ! ;
: HEX 16 BASE ! ;
: U. BASE @ /MOD ?DUP IF RECURSE THEN DUP 10 < IF '0' ELSE 10 - 'A' THEN + EMIT ;
: .S DSP@ BEGIN DUP S0 @ < WHILE DUP @ U. SPACE 4+ REPEAT DROP ;
: UWIDTH BASE @ / ?DUP IF RECURSE 1+ ELSE 1 THEN ;
: U.R SWAP DUP UWIDTH ROT SWAP - SPACES U. ;
: .R SWAP DUP 0< IF NEGATE 1 SWAP ROT 1- ELSE 0 SWAP ROT THEN SWAP DUP UWIDTH ROT SWAP - SPACES SWAP IF '-' EMIT THEN U. ;
: . 0 .R SPACE ;
: U. U. SPACE ;
: ? @ . ;
: WITHIN -ROT OVER <= IF > IF TRUE ELSE FALSE THEN ELSE 2DROP FALSE THEN ;
: DEPTH S0 @ DSP@ - 4- ;
: ALIGNED 3 + 3 INVERT AND ;
: ALIGN HERE @ ALIGNED HERE ! ;
: C, HERE @ C! 1 HERE +! ;
: S" IMMEDIATE STATE @ IF ' LITSTRING , HERE @ 0 , BEGIN KEY DUP '"' <> WHILE C, REPEAT DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN ELSE HERE @ BEGIN KEY DUP '"' <> WHILE OVER C! 1+ REPEAT DROP HERE @ - HERE @ SWAP THEN ;
: ." IMMEDIATE STATE @ IF [COMPILE] S" ' TELL , ELSE BEGIN KEY DUP '"' = IF DROP EXIT THEN EMIT AGAIN THEN ;
: CONSTANT WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
: ALLOT HERE @ SWAP HERE +! ;
: CELLS 4 * ;
: VARIABLE 1 CELLS ALLOT WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
: VALUE WORD CREATE DOCOL , ' LIT , , ' EXIT , ;
: TO IMMEDIATE WORD FIND >DFA 4+ STATE @ IF ' LIT , , ' ! , ELSE ! THEN ;
: +TO IMMEDIATE WORD FIND >DFA 4+ STATE @ IF ' LIT , , ' +! , ELSE +! THEN ;
: ID. 4+ DUP C@ F_LENMASK AND BEGIN DUP 0> WHILE SWAP 1+ DUP C@ EMIT SWAP 1- REPEAT 2DROP ;
: ?HIDDEN 4+ C@ F_HIDDEN AND ;
: ?IMMEDIATE 4+ C@ F_IMMED AND ;
: WORDS LATEST @ BEGIN ?DUP WHILE DUP ?HIDDEN NOT IF DUP ID. SPACE THEN @ REPEAT CR ;
: FORGET WORD FIND DUP @ LATEST ! HERE ! ;
: DUMP BASE @ -ROT HEX BEGIN ?DUP WHILE OVER 8 U.R SPACE 2DUP 1- 15 AND 1+ BEGIN ?DUP WHILE SWAP DUP C@ 2 .R SPACE 1+ SWAP 1- REPEAT DROP 2DUP 1- 15 AND 1+ BEGIN ?DUP WHILE SWAP DUP C@ DUP 32 128 WITHIN IF EMIT ELSE DROP '.' EMIT THEN 1+ SWAP 1- REPEAT DROP CR DUP 1- 15 AND 1+ TUCK - >R + R> REPEAT DROP BASE ! ;
: CASE IMMEDIATE 0 ;
: OF IMMEDIATE ' OVER , ' = , [COMPILE] IF ' DROP , ;
: ENDOF IMMEDIATE [COMPILE] ELSE ;
: ENDCASE IMMEDIATE ' DROP , BEGIN ?DUP WHILE [COMPILE] THEN REPEAT ;
: CFA> LATEST @ BEGIN ?DUP WHILE 2DUP SWAP < IF NIP EXIT THEN @ REPEAT DROP 0 ;
: SEE WORD FIND HERE @ LATEST @ BEGIN 2 PICK OVER <> WHILE NIP DUP @ REPEAT DROP SWAP ':' EMIT SPACE DUP ID. SPACE DUP ?IMMEDIATE IF ." IMMEDIATE " THEN >DFA BEGIN 2DUP > WHILE DUP @ CASE ' LIT OF 4 + DUP @ . ENDOF ' LITSTRING OF [ CHAR S ] LITERAL EMIT '"' EMIT SPACE 4 + DUP @ SWAP 4 + SWAP 2DUP TELL '"' EMIT SPACE + ALIGNED 4 - ENDOF ' 0BRANCH OF ." 0BRANCH ( " 4 + DUP @ . ." ) " ENDOF ' BRANCH OF ." BRANCH ( " 4 + DUP @ . ." ) " ENDOF ' ' OF [ CHAR ' ] LITERAL EMIT SPACE 4 + DUP @ CFA> ID. SPACE ENDOF ' EXIT OF 2DUP 4 + <> IF ." EXIT " THEN ENDOF DUP CFA> ID. SPACE ENDCASE 4 + REPEAT ';' EMIT CR 2DROP ;
: :NONAME 0 0 CREATE HERE @ DOCOL , ] ;
: ['] IMMEDIATE ' LIT , ;
: EXCEPTION-MARKER RDROP 0 ;
: CATCH DSP@ 4+ >R ' EXCEPTION-MARKER 4+ >R EXECUTE ;
: THROW ?DUP IF RSP@ BEGIN DUP R0 4- < WHILE DUP @ ' EXCEPTION-MARKER 4+ = IF 4+ RSP! DUP DUP DUP R> 4- SWAP OVER ! DSP! EXIT THEN 4+ REPEAT DROP CASE 0 1- OF ." ABORTED" CR ENDOF ." UNCAUGHT THROW " DUP . CR ENDCASE QUIT THEN ;
: ABORT 0 1- THROW ;
: PRINT-STACK-TRACE RSP@ BEGIN DUP R0 4- < WHILE DUP @ CASE ' EXCEPTION-MARKER 4+ OF ." CATCH ( DSP=" 4+ DUP @ U. ." ) " ENDOF DUP CFA> ?DUP IF 2DUP ID. [ CHAR + ] LITERAL EMIT SWAP >DFA 4+ - . THEN ENDCASE 4+ REPEAT DROP CR ;
: Z" IMMEDIATE STATE @ IF ' LITSTRING , HERE @ 0 , BEGIN KEY DUP '"' <> WHILE HERE @ C! 1 HERE +! REPEAT 0 HERE @ C! 1 HERE +! DROP DUP HERE @ SWAP - 4- SWAP ! ALIGN ' DROP , ELSE HERE @ BEGIN KEY DUP '"' <> WHILE OVER C! 1+ REPEAT DROP 0 SWAP C! HERE @ THEN ;
: STRLEN DUP BEGIN DUP C@ 0<> WHILE 1+ REPEAT SWAP - ;
: CSTRING SWAP OVER HERE @ SWAP CMOVE HERE @ + 0 SWAP C! HERE @ ;
: ARGC S0 @ @ ;
: ARGV 1+ CELLS S0 @ + @ DUP STRLEN	;
: ENVIRON ARGC 2 + CELLS S0 @ + ;
: BYE 0 SYS_EXIT SYSCALL1 ;
: GET-BRK 0 SYS_BRK SYSCALL1 ;
: UNUSED GET-BRK HERE @ - 4 / ;
: BRK SYS_BRK SYSCALL1 ;
: MORECORE CELLS GET-BRK + BRK ;
: R/O O_RDONLY ;
: R/W O_RDWR ;
: OPEN-FILE	-ROT CSTRING SYS_OPEN SYSCALL2 DUP DUP 0< IF NEGATE ELSE DROP 0 THEN ;
: CREATE-FILE O_CREAT OR O_TRUNC OR -ROT CSTRING 420 -ROT SYS_OPEN SYSCALL3 DUP DUP 0< IF NEGATE ELSE DROP 0 THEN ;
: CLOSE-FILE SYS_CLOSE SYSCALL1 NEGATE ;
: READ-FILE >R SWAP R> SYS_READ SYSCALL3 DUP DUP 0< IF NEGATE ELSE DROP 0 THEN ;
: PERROR TELL ':' EMIT SPACE ." ERRNO=" . CR ;
: ;CODE IMMEDIATE [COMPILE] NEXT ALIGN LATEST @ DUP HIDDEN DUP >DFA SWAP >CFA ! [COMPILE] [ ;
: EAX IMMEDIATE 0 ;
: ECX IMMEDIATE 1 ;
: EDX IMMEDIATE 2 ;
: EBX IMMEDIATE 3 ;
: ESP IMMEDIATE 4 ;
: EBP IMMEDIATE 5 ;
: ESI IMMEDIATE 6 ;
: EDI IMMEDIATE 7 ;
: PUSH IMMEDIATE 50 + C, ;
: POP IMMEDIATE 58 + C, ;
: RDTSC IMMEDIATE 0F C, 31 C, ;
: RDTSC RDTSC EAX PUSH EDX PUSH ;CODE
: =NEXT DUP C@ AD <> IF DROP FALSE EXIT THEN 1+ DUP C@ FF <> IF DROP FALSE EXIT THEN 1+ C@ 20 <> IF FALSE EXIT THEN TRUE ;
: (INLINE) @ BEGIN DUP =NEXT NOT WHILE DUP C@ C, 1+ REPEAT DROP ;
: INLINE IMMEDIATE WORD FIND >CFA DUP @ DOCOL = IF ." Cannot INLINE FORTH words" CR ABORT THEN (INLINE) ;
: WELCOME S" TEST-MODE" FIND NOT IF ." JONESFORTH VERSION " VERSION . CR UNUSED . ." CELLS REMAINING" CR ." OK " THEN ;
